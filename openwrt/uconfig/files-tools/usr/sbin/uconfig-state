#!/usr/bin/ucode

'use strict';

import * as datamodel from 'cli.datamodel';
import { readfile, popen } from 'fs';
import * as libubus from 'ubus';
import * as uloop from 'uloop';

let ubus = libubus.connect();
let pending = false;
let devices = {};
let l3_devices;
let capabilities = json(readfile('/etc/uconfig/capabilities.json'));

let model = datamodel.new();
model.add_modules();
model.init();
let cli = model.context();
cli = cli.select([ 'uconfig' ]);

function add_mac(stations, mac) {
	stations[mac] ??= {
		mac,
	};
}

function network_interfaces() {
	let ifaces = ubus.call('network.interface', 'dump');
	l3_devices = {};

	for (let iface in ifaces.interface) {
		if (iface.interface in ['main', 'guest', 'uplink'])
			l3_devices[iface.l3_device] = iface.interface;
	}
}

function arp(stations) {
	let pipe = popen('ip neigh');
	let neigh = pipe.read("all");
	pipe.close();

	let lines = split(neigh, '\n');

	for (let line in lines) {
		let values = split(line, ' ');
		if (length(values) < 6)
			continue;

		let mac = uc(values[4]);
		add_mac(stations, mac);

		if (l3_devices[values[2]])
			stations[mac].network = l3_devices[values[2]];

		if (length(values[0]) < 16) {
			stations[mac].ipv4 ??= values[0];
		} else {
			stations[mac].ipv6 ??= [];
			push(stations[mac].ipv6, values[0]);
		}
	}
}

function assoc_list(stations) {
	let clients = ubus.call('rrm', 'get_clients');

	for (let mac, client in clients) {
		mac = uc(mac);
		add_mac(stations, mac);
		stations[mac].network = client.network;
		delete client.network;
		stations[mac].wifi = client;
	}
}

function fingerprint(stations) {
	for (let mac, fingerprint in ubus.call('fingerprint', 'fingerprint')) {
		mac = uc(mac);
		add_mac(stations, mac);
		stations[mac].fingerprint = fingerprint;
		if (fingerprint.device_name || fingerprint.device)
			stations[mac].hostname = fingerprint.device_name || fingerprint.device;
	}
}

function dhcp_leases(stations) {
	let static = {
		lan: cli.call(['edit', 'interface', 'main', 'ipv4', 'list', 'dhcp-lease']).data,
		guest: cli.call(['edit', 'interface', 'guest', 'ipv4', 'list', 'dhcp-lease']).data,
	};

	let leases = readfile('/tmp/dhcp.leases');
	let lines = split(leases, '\n');

	for (let line in lines) {
		let values = split(line, ' ');
		if (length(values) != 5)
			continue;
		
		let mac = uc(values[1]);

		add_mac(stations, mac);
		stations[mac].ipv4 = values[2];
		stations[mac].dhcp = (mac in static[stations[mac].network]) ? 'static' : 'dynamic';
		if (values[3] != '*')
			stations[mac].hostname ??= values[3];
	}
}

function nlbwmon(stations) {
	let pipe = popen('nlbw -c show -c json');
	let data = json(pipe.read("all") || '{}');
	pipe.close();
	if (!data?.data)
		return;
	data = data.data;
	for (let traffic in data) {
		let mac = uc(traffic[3]);
		if (!stations[mac])
			continue;
		let type = traffic[10] || 'unknown';
		stations[mac].bytes ??= 0;
		stations[mac].traffic ??= {};
		stations[mac].traffic[type] ??= { bytes: 0 };
		stations[mac].traffic[type].bytes += traffic[6] + traffic[8];
		stations[mac].bytes += traffic[6] + traffic[8];
	}
}

function update() {
	if (pending)
		return;

	let stations = {};
	pending = true;
	network_interfaces();
	arp(stations);

	assoc_list(stations);
	fingerprint(stations);
	dhcp_leases(stations);
	nlbwmon(stations);

	let new_devices = {};

	for (let mac, station in stations) {
		if (!station?.network)
			continue;
		new_devices[station.network] ??= {};
		new_devices[station.network][mac] = station;	
		if (station.mac)
			delete station.mac;
		if (station.network)
			delete station.network;
	}

	devices = new_devices;
	pending = false;
}

function ports(args) {
	let status = ubus.call('network.device', 'status');
	let roles = {};
	let ports;

	if (args.network) {
		ports = readfile(`/tmp/uconfig/ports.${args.network}`);
		if (ports)
			ports = json(ports);
	}

	for (let role in [ 'wan', 'lan' ]) {
		let spec = capabilities.network[role];
		for (let i, ifname in spec) {
			role = uc(role);
			if (ports && !(ifname in ports))
				continue;
			push(roles[role] = roles[role] || [], {
				netdev: ifname,
				index: i,
				carrier: status[ifname].carrier,
				speed: status[ifname].speed,
				macaddr: status[ifname].macaddr,
				rx_bytes: status[ifname].statistics.rx_bytes,
				tx_bytes: status[ifname].statistics.tx_bytes,
			});
		}
	}

	let rv = {};

	for (let role, ports in roles) {
		switch (length(ports)) {
		case 0:
			break;

		case 1:
			rv[role] = ports[0];
			break;

		default:
			map(sort(ports, (a, b) => (a.index - b.index)), (port, i) => {
				rv[role + (i + 1)] = port;
			});
		}
	}
	return rv;
}

let ubus_methods = {
	devices: {
		call: function(req) {
			return devices;
		},
		args: {
		}
	},
	ports: {
		call: function(req) {
			return ports(req.args);
		},
		args: {
			network: '',
		}
	},
	update: {
		call: function(req) {
			update();
			return 0;
		},
		args: {
		}
	},
};

uloop.init();
ubus.publish("state", ubus_methods);
let updateInterval;
updateInterval = uloop.interval(60 * 1000, () => {
	updateInterval.set(5 * 60 * 1000);
	update();
});

uloop.run();
uloop.done();
